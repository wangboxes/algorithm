package com.wbx.algorithm._04_递归;

/**
 * @describe： 递归:函数(方法)直接或间接调用自身。是一种常用的编程技巧
 * @Date：2019-10-31 22:44
 * @author：wbx
 *
 * 注意：使用递归不是为了求得最优解，是为了简化解决问题的思路，代码会更加简洁
 * ◼ 递归求出来的很有可能不是最优解，也有可能是最优解
 */
public class Recursion {

    /**
     * 直接调用自身
     * 时间复杂度： O(n)
     * 空间复杂度： O(n)
     * @param n
     * @return
     */
    public static int sum1(int n) {
        /**
         * 如果递归调用没有终止，将会一直消耗栈空间
         * 最终导致栈内存溢出（ Stack Overflow）
         * ◼ 所以必需要有一个明确的结束递归的条件
         * 也叫作边界条件、递归基
         */
        if (n <= 1) {
            return 1;
        }
        //函数调用会消耗栈空间，空间复杂度：O(n)
        return n + sum1(n - 1);
    }


    /**
     * 时间复杂度： O(n)
     * 空间复杂度： O(1)
     * @param n
     * @return
     */
    public static int sum2(int n) {
        int result = 0;
        for (int i = 1; i <= n; i++) {
            result += i;
        }
        return result;
    }

    /**
     * 时间复杂度： O(1)
     * 空间复杂度： O(1)
     * @param n
     * @return
     */
    public static int sum3(int n) {
        if (n <= 1) {
            return n;
        }
        return (1 + n) * n >> 1;
    }


    /**
     * 间接调用自身
     *
     * @param v
     */
    public static void a(int v) {
        if (v < 0) {
            return;
        }
        b(--v);
    }

    private static void b(int v) {
        a(--v);
    }

    /**
     * 递归的基本思想
     * ◼ 拆解问题
     * 把规模大的问题变成规模较小的同类型问题
     * 规模较小的问题又不断变成规模更小的问题
     * 规模小到一定程度可以直接得出它的解
     *
     * ◼ 求解
     * 由最小规模问题的解得出较大规模问题的解
     * 由较大规模问题的解不断得出规模更大问题的解
     * 最后得出原来问题的解
     *
     * ◼ 凡是可以利用上述思想解决问题的，都可以尝试使用递归
     * 很多链表、二叉树相关的问题都可以使用递归来解决
     * ✓ 因为链表、二叉树本身就是递归的结构（链表中包含链表，二叉树中包含二叉树）
     *
     *
     *
     *递归的使用套路
     * ① 明确函数的功能
     * 先不要去思考里面代码怎么写，首先搞清楚这个函数的干嘛用的，能完成什么功能？
     *
     * ② 明确原问题与子问题的关系
     * ◼ 寻找 f(n) 与 f(n – 1) 的关系
     *
     * ③ 明确递归基（边界条件）
     * ◼ 递归的过程中，子问题的规模在不断减小，当小到一定程度时可以直接得出它的解
     * 寻找递归基，相当于是思考：问题规模小到什么程度可以直接得出解？
     *
     *
     *
     *
     * ◼ 递归调用的空间复杂度 = 递归深度 * 每次调用所需的辅助空间
     */

}
